<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>missmecha.generate.mnar &#8212; MissMecha</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=f79d278b" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=4f46311c" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script src="../../../_static/documentation_options.js?v=f539c95a"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    <p class="title logo__title">MissMecha</p>
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class=" collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../usage.html">
  Project Overview
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../installation.html">
  Installation
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../theory.html">
  Theory
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../modules.html">
  Modules
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../examples.html">
  Examples
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../about.html">
  About Us
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../../../contribution.html">
  Contribution Guidelines
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/echoid/MissMecha" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pypi.org/project/missmecha-py/" rel="noopener" target="_blank" title="PyPI"><span><i class="fas fa-box"></i></span>
            <label class="sr-only">PyPI</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <h1>Source code for missmecha.generate.mnar</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="c1"># Rewrite pick_coeffs and fit_intercepts in pure NumPy (no torch)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">expit</span>  <span class="c1"># sigmoid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">bisect</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_pick_coeffs_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">idxs_obs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">idxs_nas</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">self_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">self_mask</span><span class="p">:</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">Wx</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">coeffs</span>
        <span class="n">coeffs</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Wx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d_obs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs_obs</span><span class="p">)</span>
        <span class="n">d_na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idxs_nas</span><span class="p">)</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">d_obs</span><span class="p">,</span> <span class="n">d_na</span><span class="p">)</span>
        <span class="n">Wx</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">idxs_obs</span><span class="p">]</span> <span class="o">@</span> <span class="n">coeffs</span>
        <span class="n">coeffs</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">Wx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coeffs</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_fit_intercepts_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">self_mask</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">self_mask</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span>
        <span class="n">intercepts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">expit</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">p</span>
            <span class="n">intercepts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d_obs</span><span class="p">,</span> <span class="n">d_na</span> <span class="o">=</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">intercepts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d_na</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d_na</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">expit</span><span class="p">(</span><span class="n">X</span> <span class="o">@</span> <span class="n">coeffs</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">))</span> <span class="o">-</span> <span class="n">p</span>
            <span class="n">intercepts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">intercepts</span>

<div class="viewcode-block" id="MNARType1">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType1">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MNARType1</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MNAR Mechanism - Type 1 (Quantile-Based Threshold Masking)</span>

<span class="sd">    Introduces missingness based on whether values exceed a column-specific threshold,</span>
<span class="sd">    defined by a quantile (e.g., top 20%). This is applied to both the target columns</span>
<span class="sd">    and optionally conditioned on extreme observed values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    missing_rate : float, default=0.1</span>
<span class="sd">        Approximate proportion of values to be masked.</span>
<span class="sd">    seed : int, default=1</span>
<span class="sd">        Random seed for reproducibility.</span>
<span class="sd">    up_percentile : float, default=0.5</span>
<span class="sd">        Quantile threshold above which values in the masking column are considered extreme.</span>
<span class="sd">    obs_percentile : float, default=0.5</span>
<span class="sd">        Threshold for additional conditioning on observed values (used when available).</span>
<span class="sd">    depend_on : Ignored</span>
<span class="sd">        Present for API compatibility; not used in this type.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">missing_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">up_percentile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">obs_percentile</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">depend_on</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span> <span class="o">=</span> <span class="n">missing_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">up_percentile</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">missing_rate</span> <span class="k">if</span> <span class="n">up_percentile</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">up_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obs_percentile</span> <span class="o">=</span> <span class="n">obs_percentile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MNARType1.fit">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType1.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Precompute masking thresholds for each target column using quantile cutoffs.</span>

<span class="sd">        The data is scaled column-wise to [0, 1] before calculating quantiles.</span>
<span class="sd">        One threshold per column is stored for use in the transformation step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input numerical data.</span>
<span class="sd">        y : Ignored</span>
<span class="sd">            Included for interface compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : MNARType1</span>
<span class="sd">            Fitted object with threshold values stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">scale_data</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">min_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">max_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">min_vals</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_vals</span> <span class="o">-</span> <span class="n">min_vals</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">scale_data</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1">#n_miss_cols = int(n_cols * self.missing_rate)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">miss_cols</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_cols</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_cols</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Store thresholds for each missing column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thresholds_miss</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">miss_cols</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">thresholds_miss</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">col</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">up_percentile</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MNARType1.transform">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType1.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply quantile-based missingness to the dataset.</span>

<span class="sd">        For each selected column, values greater than the quantile threshold</span>
<span class="sd">        are masked. Optionally, further filtering can be applied based on observed</span>
<span class="sd">        values in the remaining columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data to apply missingness.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_missing : np.ndarray</span>
<span class="sd">            Data with NaNs inserted based on precomputed thresholds.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Call .fit() before .transform().&quot;</span><span class="p">)</span>

        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">scale_data</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">min_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">max_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">min_vals</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">max_vals</span> <span class="o">-</span> <span class="n">min_vals</span> <span class="o">+</span> <span class="mf">1e-8</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">scale_data</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">n_cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">obs_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cols</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">miss_cols</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">miss_col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">miss_cols</span><span class="p">:</span>
            <span class="n">threshold_miss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">thresholds_miss</span><span class="p">[</span><span class="n">miss_col</span><span class="p">]</span>
            <span class="n">mask_condition_1</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">miss_col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold_miss</span>

            <span class="k">if</span> <span class="n">obs_cols</span><span class="p">:</span>
                <span class="n">obs_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">mask_condition_1</span><span class="p">][:,</span> <span class="n">obs_cols</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">obs_data</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">threshold_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">obs_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obs_percentile</span><span class="p">)</span>
                    <span class="n">mask_condition_2</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">miss_col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold_obs</span>
                    <span class="n">merged_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask_condition_1</span><span class="p">,</span> <span class="n">mask_condition_2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">merged_mask</span> <span class="o">=</span> <span class="n">mask_condition_1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged_mask</span> <span class="o">=</span> <span class="n">mask_condition_1</span>

            <span class="n">mask</span><span class="p">[:,</span> <span class="n">miss_col</span><span class="p">]</span> <span class="o">=</span> <span class="o">~</span><span class="n">merged_mask</span>

        <span class="n">data_with_missing</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">data_with_missing</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">data_with_missing</span></div>
</div>



<div class="viewcode-block" id="MNARType2">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType2">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MNARType2</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MNAR Mechanism - Type 2 (Logistic Missingness Using Observed Features)</span>

<span class="sd">    Simulates missingness by fitting a logistic model over a subset of the input features,</span>
<span class="sd">    and then masking values in the remaining columns based on predicted probabilities.</span>

<span class="sd">    If `exclude_inputs=True`, input features are excluded from missingness and used only</span>
<span class="sd">    as predictors. Otherwise, all features can be masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    missing_rate : float, default=0.1</span>
<span class="sd">        Target overall proportion of missing values.</span>
<span class="sd">    para : float, default=0.3</span>
<span class="sd">        Proportion of columns used as logistic predictors.</span>
<span class="sd">    exclude_inputs : bool, default=True</span>
<span class="sd">        Whether to exclude input (predictor) features from being masked.</span>
<span class="sd">    seed : int, default=1</span>
<span class="sd">        Random seed for reproducibility.</span>
<span class="sd">    depend_on : Ignored</span>
<span class="sd">        Present for compatibility; not used in this mechanism.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">missing_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">para</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">exclude_inputs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depend_on</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span> <span class="o">=</span> <span class="n">missing_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_params</span> <span class="o">=</span> <span class="n">para</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exclude_inputs</span> <span class="o">=</span> <span class="n">exclude_inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MNARType2.fit">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType2.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a logistic model to predict missingness probabilities.</span>

<span class="sd">        Randomly selects a subset of columns as predictors (based on `para`) and learns</span>
<span class="sd">        logistic coefficients and intercepts for the remaining columns. These will be</span>
<span class="sd">        used to determine masking during `transform()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data matrix.</span>
<span class="sd">        y : Ignored</span>
<span class="sd">            Included for API compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : MNARType2</span>
<span class="sd">            Fitted object with learned parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span> <span class="o">=</span> <span class="n">d</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">d_params</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_params</span> <span class="o">*</span> <span class="n">d</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude_inputs</span> <span class="k">else</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_na</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_params</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude_inputs</span> <span class="k">else</span> <span class="n">d</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">idxs_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_params</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude_inputs</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idxs_nas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_params</span><span class="p">])</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude_inputs</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">_pick_coeffs_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_nas</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercepts</span> <span class="o">=</span> <span class="n">_fit_intercepts_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_params</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MNARType2.transform">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType2.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply logistic missingness using learned probabilities.</span>

<span class="sd">        Probabilities are computed using the fitted logistic model, and missingness is</span>
<span class="sd">        introduced accordingly. If `exclude_inputs=True`, masking is restricted to the</span>
<span class="sd">        non-predictor columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_missing : np.ndarray</span>
<span class="sd">            Data matrix with missing values injected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Call .fit() before .transform().&quot;</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_params</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercepts</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_nas</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_na</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ps</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exclude_inputs</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_params</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span>

        <span class="n">X_missing</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">X_missing</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">X_missing</span></div>
</div>

<div class="viewcode-block" id="MNARType3">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType3">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MNARType3</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MNAR Mechanism - Type 3 (Self-Masking with Logistic Probabilities)</span>

<span class="sd">    A self-masking mechanism where each feature determines its own missingness</span>
<span class="sd">    probability via a feature-wise logistic function. Coefficients and intercepts</span>
<span class="sd">    are learned for each column independently.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    missing_rate : float, default=0.1</span>
<span class="sd">        Target proportion of missing values.</span>
<span class="sd">    seed : int, default=1</span>
<span class="sd">        Random seed for reproducibility.</span>
<span class="sd">    depend_on : Ignored</span>
<span class="sd">        Present for compatibility; not used in this mechanism.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">missing_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depend_on</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span> <span class="o">=</span> <span class="n">missing_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MNARType3.fit">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType3.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit a logistic model for each feature using its own values as input.</span>

<span class="sd">        For every column, a separate set of logistic coefficients and intercepts</span>
<span class="sd">        are computed to match the specified `missing_rate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data matrix.</span>
<span class="sd">        y : Ignored</span>
<span class="sd">            Included for interface compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : MNARType3</span>
<span class="sd">            Fitted object with per-feature logistic models.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="n">_pick_coeffs_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">self_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercepts</span> <span class="o">=</span> <span class="n">_fit_intercepts_numpy</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span><span class="p">,</span> <span class="n">self_mask</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MNARType3.transform">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType3.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply self-masking based on feature-wise logistic models.</span>

<span class="sd">        Each column masks its own values independently according to the logistic</span>
<span class="sd">        probability computed from the feature&#39;s value and learned intercept.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data matrix.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_missing : np.ndarray</span>
<span class="sd">            Transformed matrix with missing entries introduced column-wise.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Call .fit() before .transform().&quot;</span><span class="p">)</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">expit</span><span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercepts</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ps</span>
        <span class="n">X_missing</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">X_missing</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">X_missing</span></div>
</div>

    
<div class="viewcode-block" id="MNARType4">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType4">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MNARType4</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MNAR Mechanism - Type 4 (Quantile Cutoff Masking with Optional Upper/Lower/Both)</span>

<span class="sd">    Introduces missingness based on whether feature values lie above, below, or at both</span>
<span class="sd">    extremes of a specified quantile cutoff. Offers flexible selection for cutoff direction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    missing_rate : float, default=0.1</span>
<span class="sd">        Proportion of values to be masked.</span>
<span class="sd">    q : float, default=0.25</span>
<span class="sd">        Quantile value used to define cutoff thresholds (e.g., q=0.25 for 25% tails).</span>
<span class="sd">    p : float, default=0.5</span>
<span class="sd">        Proportion of columns to be affected.</span>
<span class="sd">    cut : {&quot;upper&quot;, &quot;lower&quot;, &quot;both&quot;}, default=&quot;both&quot;</span>
<span class="sd">        Defines which side(s) of the distribution will be masked.</span>
<span class="sd">    seed : int, default=1</span>
<span class="sd">        Random seed for reproducibility.</span>
<span class="sd">    depend_on : Ignored</span>
<span class="sd">        Present for compatibility; not used in this mechanism.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">missing_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depend_on</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span> <span class="o">=</span> <span class="n">missing_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_params</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">=</span> <span class="n">cut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MNARType4.fit">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType4.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Precompute cutoff thresholds for each column.</span>

<span class="sd">        Depending on the `cut` parameter, stores upper, lower, or both quantile</span>
<span class="sd">        thresholds for selected columns. Columns are chosen randomly based on `p`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data matrix.</span>
<span class="sd">        y : Ignored</span>
<span class="sd">            Included for API compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : MNARType4</span>
<span class="sd">            Fitted object with quantile thresholds stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1">#self.X_shape = (n, d)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">idxs_na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_params</span> <span class="o">*</span> <span class="n">d</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idxs_na</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">quants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idxs_na</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_quants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idxs_na</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_quants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">idxs_na</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MNARType4.transform">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType4.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply missingness to values beyond the selected quantile cutoffs.</span>

<span class="sd">        Missing values are introduced into the selected columns where entries fall</span>
<span class="sd">        beyond the precomputed upper, lower, or both quantiles. A Bernoulli sampling</span>
<span class="sd">        is used to approximate the target `missing_rate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data matrix to transform.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_missing : np.ndarray</span>
<span class="sd">            Transformed data with missing entries injected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Call .fit() before .transform().&quot;</span><span class="p">)</span>
        
        
        <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p_params</span> <span class="o">*</span> <span class="n">d</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="s2">&quot;upper&quot;</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quants</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="s2">&quot;lower&quot;</span><span class="p">:</span>
            <span class="n">quants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quants</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut</span> <span class="o">==</span> <span class="s2">&quot;both&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">u_quants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">l_quants</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_quants</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">u_quants</span><span class="p">)</span>

        <span class="n">ber</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">))</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">idxs_na</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ber</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">m</span>

        <span class="n">X_missing</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">X_missing</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">X_missing</span></div>
</div>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">expit</span> <span class="k">as</span> <span class="n">sigmoid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">optimize</span>

<div class="viewcode-block" id="MNARType5">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType5">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MNARType5</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MNAR Mechanism - Type 5 (Single-Column Self-Masking with Fitted Intercepts)</span>

<span class="sd">    Introduces missingness for each column independently by fitting a logistic function</span>
<span class="sd">    to its own values. A coefficient and intercept are learned per feature.</span>

<span class="sd">    This mechanism is suitable for per-column missingness and assumes that the missingness</span>
<span class="sd">    probability depends only on the value of the feature itself.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    missing_rate : float, default=0.1</span>
<span class="sd">        Desired proportion of missing values per column.</span>
<span class="sd">    seed : int, default=1</span>
<span class="sd">        Random seed for reproducibility.</span>
<span class="sd">    depend_on : Ignored</span>
<span class="sd">        Included for API compatibility.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">missing_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depend_on</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span> <span class="o">=</span> <span class="n">missing_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_pick_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
        <span class="n">Wx</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">coeffs</span>
        <span class="n">stds</span> <span class="o">=</span> <span class="n">Wx</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">stds</span><span class="p">[</span><span class="n">stds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Avoid divide-by-zero</span>
        <span class="n">coeffs</span> <span class="o">/=</span> <span class="n">stds</span>
        <span class="k">return</span> <span class="n">coeffs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fit_intercepts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">intercepts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">intercepts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">intercepts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># fallback if bisection fails</span>
        <span class="k">return</span> <span class="n">intercepts</span>

<div class="viewcode-block" id="MNARType5.fit">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType5.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit feature-wise logistic coefficients and intercepts.</span>

<span class="sd">        For each column, learns a logistic intercept such that the expected</span>
<span class="sd">        proportion of missing values matches the `missing_rate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input numerical data (n_samples, n_features).</span>
<span class="sd">        y : Ignored</span>
<span class="sd">            Present for compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : MNARType5</span>
<span class="sd">            Fitted object with per-column logistic parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_coeffs</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercepts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fit_intercepts</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MNARType5.transform">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType5.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply self-masking to each column based on learned probabilities.</span>

<span class="sd">        For each feature, a logistic model is used to compute the probability</span>
<span class="sd">        of masking, and missing values are introduced accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray</span>
<span class="sd">            Input data matrix to apply missingness.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_missing : np.ndarray</span>
<span class="sd">            Transformed data with per-feature missing entries.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Call .fit() before .transform().&quot;</span><span class="p">)</span>

        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeffs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercepts</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">probs</span>

        <span class="n">X_missing</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">X_missing</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">X_missing</span></div>
</div>



<div class="viewcode-block" id="MNARType6">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType6">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">MNARType6</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    MNAR Mechanism - Type 6 (Percentile-Based Per-Column Thresholding)</span>

<span class="sd">    Introduces missingness separately for each column, based on whether values fall</span>
<span class="sd">    below a specified percentile threshold. This allows for fine-grained, column-wise</span>
<span class="sd">    control of missingness and supports both NumPy arrays and pandas DataFrames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    missing_rate : float, default=0.1</span>
<span class="sd">        Threshold percentile for masking (e.g., 0.1 = bottom 10% values become missing).</span>
<span class="sd">    seed : int, default=1</span>
<span class="sd">        Random seed for reproducibility.</span>
<span class="sd">    depend_on : Ignored</span>
<span class="sd">        Present for compatibility.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">missing_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">depend_on</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span> <span class="o">=</span> <span class="n">missing_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seed</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="MNARType6.fit">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType6.fit">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute per-column thresholds based on the given percentile.</span>

<span class="sd">        For each feature, a percentile cutoff is calculated and stored. During transform,</span>
<span class="sd">        values below this cutoff will be masked.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray or pd.DataFrame</span>
<span class="sd">            Input data used to calculate percentile thresholds.</span>
<span class="sd">        y : Ignored</span>
<span class="sd">            Present for API compatibility.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : MNARType6</span>
<span class="sd">            Fitted object with threshold values stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seed</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_features</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cutoffs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features</span><span class="p">):</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">col</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_rate</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cutoffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span></div>


<div class="viewcode-block" id="MNARType6.transform">
<a class="viewcode-back" href="../../../modules/generate_fun/mnar_numerical.html#missmecha.generate.mnar.MNARType6.transform">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply per-column masking to values below the learned percentile thresholds.</span>

<span class="sd">        Automatically handles both NumPy arrays and pandas DataFrames. If input is a</span>
<span class="sd">        DataFrame, missing values will be inserted by column name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : np.ndarray or pd.DataFrame</span>
<span class="sd">            Input data matrix to apply missingness.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        X_missing : np.ndarray or pd.DataFrame</span>
<span class="sd">            Transformed data with missing entries inserted.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Call .fit() before .transform().&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_df</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_array</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">X_missing</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_features</span><span class="p">):</span>
            <span class="n">X_missing</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoffs</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">col</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">X_missing</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_transform_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="n">X_missing</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">X_missing</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoffs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">df</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">X_missing</span></div>



<span class="n">MNAR_TYPES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="n">MNARType1</span><span class="p">,</span>
    <span class="mi">2</span><span class="p">:</span> <span class="n">MNARType2</span><span class="p">,</span>
    <span class="mi">3</span><span class="p">:</span> <span class="n">MNARType3</span><span class="p">,</span>
    <span class="mi">4</span><span class="p">:</span> <span class="n">MNARType4</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">:</span> <span class="n">MNARType5</span><span class="p">,</span>
    <span class="mi">6</span><span class="p">:</span> <span class="n">MNARType6</span>

<span class="p">}</span>


<span class="c1"># def make_mnar_columnwise(data, col_info, q, random_seed=1):</span>
<span class="c1">#     np.random.seed(random_seed)</span>
<span class="c1">#     random.seed(random_seed)</span>
<span class="c1">#     q = q * 100</span>
<span class="c1">#     data_mnar = data.astype(float)</span>

<span class="c1">#     missing_rates = {}</span>

<span class="c1">#     for col, col_type in col_info.items():</span>
<span class="c1">#         col_idx = int(col)  # Assuming the keys in `col_info` correspond to column indices</span>
<span class="c1">#         num_to_remove = int(len(data_mnar) * q / 100)</span>
<span class="c1">#         if &quot;numerical&quot; in col_type:</span>
<span class="c1">#             # Calculate the percentile value for the numerical column</span>
<span class="c1">#             threshold = np.percentile(data_mnar[:, col_idx], q)</span>
<span class="c1">#             # Replace values less than the threshold with np.nan</span>
<span class="c1">#             data_mnar[:, col_idx] = np.where(data_mnar[:, col_idx] &lt; threshold, np.nan, data_mnar[:, col_idx])</span>

<span class="c1">#             # Calculate the missing rate for this column</span>
<span class="c1">#             missing_rate = np.mean(np.isnan(data_mnar[:, col_idx])) * 100</span>
<span class="c1">#             missing_rates[col_idx] = missing_rate</span>
<span class="c1">#             #print(&quot;numerical&quot; ,missing_rate)</span>

<span class="c1">#         elif &quot;ordinal&quot; in col_type:</span>
<span class="c1">#             # Use the ordinal mapping from JSON to find the top two largest ordinal values</span>
<span class="c1">#             ordinal_map = col_type[&#39;ordinal&#39;]</span>
<span class="c1">#             max_value = max(ordinal_map.values())</span>

<span class="c1">#             # Find the indices where the values in the column are greater than or equal to max_value - 1</span>
<span class="c1">#             max_indices = np.where(data_mnar[:, col_idx] &gt;= (max_value - 2))[0].tolist()</span>

<span class="c1">#             # Find the rest of the indices (those not in max_indices)</span>
<span class="c1">#             all_indices = set(range(data_mnar.shape[0]))</span>
<span class="c1">#             other_indices = list(all_indices - set(max_indices))</span>

<span class="c1">#             # Determine which indices to remove based on the number to remove</span>
<span class="c1">#             if len(max_indices) &gt;= num_to_remove:</span>
<span class="c1">#                 remove_indices = random.sample(max_indices, num_to_remove)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 # If there are not enough max_indices, take all max_indices and supplement with random others</span>
<span class="c1">#                 remove_indices = max_indices</span>
<span class="c1">#                 random_indices = random.sample(other_indices, num_to_remove - len(remove_indices))</span>
<span class="c1">#                 #remove_indices = remove_indices + random_indices</span>

<span class="c1">#             data_mnar[remove_indices, col_idx] = np.nan</span>

<span class="c1">#             # Calculate the missing rate for this column</span>
<span class="c1">#             missing_rate = np.mean(np.isnan(data_mnar[:, col_idx])) * 100</span>
<span class="c1">#             missing_rates[col_idx] = missing_rate</span>
<span class="c1">#             #print(&quot;ordinal&quot; ,missing_rate)</span>

<span class="c1">#         elif &quot;nominal&quot; in col_type:</span>
<span class="c1">#             # Nominal data: Randomly choose one category and make a portion of the data missing</span>
<span class="c1">#             unique_vals = list(set(data_mnar[:, col_idx]))</span>
<span class="c1">#             chosen_val = random.choice(unique_vals)</span>

<span class="c1">#             # Get indices of the chosen category</span>
<span class="c1">#             chosen_indices = np.where(data_mnar[:, col_idx] == chosen_val )[0].tolist()</span>


<span class="c1">#             # Find the rest of the indices (those not in max_indices)</span>
<span class="c1">#             all_indices = set(range(data_mnar.shape[0]))</span>
<span class="c1">#             other_indices = list(all_indices - set(chosen_indices))</span>

<span class="c1">#             # Determine which indices to remove based on the number to remove</span>
<span class="c1">#             if len(chosen_indices) &gt;= num_to_remove:</span>
<span class="c1">#                 remove_indices = random.sample(chosen_indices, num_to_remove)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 # If there are not enough max_indices, take all max_indices and supplement with random others</span>
<span class="c1">#                 remove_indices = chosen_indices</span>
<span class="c1">#                 random_indices = random.sample(other_indices, num_to_remove - len(remove_indices))</span>
<span class="c1">#                 remove_indices = remove_indices + random_indices</span>


<span class="c1">#             data_mnar[remove_indices, col_idx] = np.nan</span>

<span class="c1">#             # Calculate the missing rate for this column</span>
<span class="c1">#             missing_rate = np.mean(np.isnan(data_mnar[:, col_idx])) * 100</span>
<span class="c1">#             #print(&quot;nominal&quot;,missing_rate)</span>
<span class="c1">#             missing_rates[col_idx] = missing_rate</span>

<span class="c1">#     return data_mnar</span>


<span class="c1"># def mnar_type5(data, missing_rate=0.1, label=None, seed=1):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     MNAR Type 5 - Self-masking on most correlated feature with label (Twala09).</span>
<span class="c1">#     The lowest values of the most label-correlated feature are masked.</span>

<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     data : np.ndarray or pd.DataFrame</span>
<span class="c1">#         Input data matrix.</span>
<span class="c1">#     missing_rate : float</span>
<span class="c1">#         Percentage (01) of missing values to insert in the selected column.</span>
<span class="c1">#     label : array-like, optional</span>
<span class="c1">#         Target variable used to determine the most correlated feature.</span>
<span class="c1">#         If None, the last column of data will be used as label.</span>
<span class="c1">#     seed : int</span>
<span class="c1">#         Random seed.</span>

<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     data_with_missing : np.ndarray</span>
<span class="c1">#         Data with NaNs inserted.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     rng = np.random.default_rng(seed)</span>

<span class="c1">#     if isinstance(data, pd.DataFrame):</span>
<span class="c1">#         data_np = data.to_numpy()</span>
<span class="c1">#     else:</span>
<span class="c1">#         data_np = data.copy()</span>

<span class="c1">#     n, p = data_np.shape</span>
<span class="c1">#     N = int(round(n * missing_rate))</span>

<span class="c1">#     if label is None:</span>
<span class="c1">#         if p &lt; 2:</span>
<span class="c1">#             raise ValueError(&quot;Data must contain at least 2 columns to use the last column as label.&quot;)</span>
<span class="c1">#         label = data_np[:, -1]</span>
<span class="c1">#         data_np = data_np[:, :-1]  # exclude label from correlation</span>

<span class="c1">#     # Correlation with label</span>
<span class="c1">#     correlations = [</span>
<span class="c1">#         abs(np.corrcoef(data_np[:, i], label)[0, 1])</span>
<span class="c1">#         if not np.isnan(data_np[:, i]).all() else 0</span>
<span class="c1">#         for i in range(data_np.shape[1])</span>
<span class="c1">#     ]</span>
<span class="c1">#     idx_xs = int(np.argmax(correlations))</span>

<span class="c1">#     # Mask lowest N values</span>
<span class="c1">#     sorted_indices = np.argsort(data_np[:, idx_xs])</span>
<span class="c1">#     missing_indices = sorted_indices[:N]</span>

<span class="c1">#     data_with_missing = data_np.copy()</span>
<span class="c1">#     data_with_missing[missing_indices, idx_xs] = np.nan</span>

<span class="c1">#     return data_with_missing</span>



<span class="c1"># def mnar_type6(data, missing_rate=0.1, column=None, seed=1):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     MNAR Type 6 - Mask highest values in a selected or random column (Xia17).</span>

<span class="c1">#     Parameters</span>
<span class="c1">#     ----------</span>
<span class="c1">#     data : np.ndarray or pd.DataFrame</span>
<span class="c1">#         Input data.</span>
<span class="c1">#     missing_rate : float</span>
<span class="c1">#         Missing rate as a float between 0 and 1.</span>
<span class="c1">#     column : int or None</span>
<span class="c1">#         If provided, mask values in this column; otherwise choose randomly.</span>
<span class="c1">#     seed : int</span>
<span class="c1">#         Random seed.</span>

<span class="c1">#     Returns</span>
<span class="c1">#     -------</span>
<span class="c1">#     data_with_missing : np.ndarray</span>
<span class="c1">#         Data with inserted NaNs.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     rng = np.random.default_rng(seed)</span>

<span class="c1">#     if isinstance(data, pd.DataFrame):</span>
<span class="c1">#         data_np = data.to_numpy()</span>
<span class="c1">#     else:</span>
<span class="c1">#         data_np = data.copy()</span>

<span class="c1">#     n, p = data_np.shape</span>
<span class="c1">#     N = int(round(n * missing_rate))</span>

<span class="c1">#     idx_xs = column if column is not None else rng.integers(0, p)</span>

<span class="c1">#     # Highest N values  NaN</span>
<span class="c1">#     sorted_indices = np.argsort(data_np[:, idx_xs])</span>
<span class="c1">#     missing_indices = sorted_indices[-N:]</span>

<span class="c1">#     data_with_missing = data_np.copy()</span>
<span class="c1">#     data_with_missing[missing_indices, idx_xs] = np.nan</span>

<span class="c1">#     return data_with_missing</span>
</pre></div>

              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2025, Youran Zhou.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.1.3.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>